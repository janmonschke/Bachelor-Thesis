### Drag & Drop
As described before, the Drag&Drop-Feature is one of the most important distinguishing features of Salon. Therefore there was the need of a good Drag&Drop-Implementation in JavaScript. Most major JavaScript libraries offer Drag&Drop-plugins today and in the beginning of development the most prominent libraries have been tried out (namely jQueryUI, mootools and script.acoul.us). They all worked great and were very feature-rich including UI-Widgets and many abstractions like automatically sortable tables, but they all lacked support for mobile browsers which is an essential feature-requirement for Salon because it should be usable on all iOs devices. Also when using one of the libraries mentioned above one had to include the whole library into the project although only the Drag&Drop functionality was needed. This would add an enormous extra load time especially for users on mobile devices.
Because of these facts I decided to write an own Drag&Drop implementation that supported webkit-mobile browsers as well as desktop browsers. There are basically two ways implement a Drag&Drop System with the given DOM-Events in JavaScript.

## GLOBAL
This implementation is called to global method because the drag-handler, a component that receives all events and maps them to drag events, stores only one DOM element at a time and associates all "global" DOM events with this element. The drag-handler starts when the mousedown-event (touchstart on webkit-mobile) is fired on an element with the css class "draggable". This element is then saved as the global drag-target together with its current position. All mousemove-/touchmove events that are then fired on the document initiate a movement-delta calculation and a custom drag-event that is fired on the current drag-target.
Drag-events will get fired until a mouseup or touchend has been fired, which means that the user has stopped dragging an element. This invokes a dragend-event being fired on the drag-target.
Although this method works perfectly on desktop browsers and also on mobile browsers it has some downsides when it comes to touch-device users. When letting iPad users drag elements around a test page they were all confused that they could only drag one element at a time. Also the drag-handler didn't work well when multiple touchstart-events were fired. The fact that element-movement is detected by move events that are fired on the document only allows to track one finger at the same time. Also the iPad users were not only confused but they also thought that the app was not working properly.

## LOCAL
To allow multiple elements to get dragged at the same time there was the need to not only associate DOM-events to one single element. Each draggable element now needed its own drag-handler and the global mousemove-events could not be used anymore. Instead of the global events in this system the local move-events are taken to fire drag events. This means that the drag-handler detects drag events from mousemove/touchmove-events that have been fired on this element. The movement delta is calculated not with one global last-position but with a last-position object that is stored for each drag-target.
A problem with this technique is that it does not work well on desktop browsers. When moving the mouse very fast the drag-target lost track of the mousemove-event and the element would stop moving although the mouse was still in movement. Somehow this problem did not appear on touch-devices so that this technique could still be used on touch devices.

The final solution uses both techniques and switches to the global system on desktop browsers and to the local system on touch-devices.
By design the system itself does not alter the positions of the images itself. To make the system as decoupled as possible this functionality has been delegated to event receivers that then can decide on their own in what way they want to move the elements on the screen (e.g. top/left CSS-attributes or negative margins). This makes it possible to create elements that can only get dragged on one axis (horizontal / vertical) or only in a certain range on the screen.

## DROP
Although this functionality is not used in Salon (yet), the Drag&Drop-system also supports the events "drop" and "drag-over". To let an element receive these events it only needs to have the CSS class "droppable" assigned. When a drag event is fired, the system looks for elements that can receive a "drag_over" event by matching the current position with the positions of all droppable elements. This event is useful to give users a feedback that they can drop elements on this element e.g. by increasing its size or by changing its color. If the user drops an element the underlying "droppable"-element will receive the drop event that includes the current drag-target.