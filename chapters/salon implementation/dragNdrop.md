[CHANGE PERSPECTIVE]
## Drag & Drop
As described before, the Drag&Drop-Feature is one of the most important distinguishing features of Salon. Therefore there was the need of a good Drag&Drop-Implementation in JavaScript. All major JavaScript libraries offer Drag&Drop-plugins today and in the beginning I had a look at the most wide spread ones (namely jQueryUI, mootools and script.acoul.us [add links??]) and tested them. They all worked great and were very feature rich including UI-Widgets and many abstractions like automatically sortable tables but they all lacked support for mobile browsers which was an essential feature I required them to have since I wanted to support at least the iPad. Also you needed to include the whole library into your project also if you only needed the Drag&Drop functionality, which would add extra load time especially for users with mobile devices.
Because of that I decided to write my own Drag&Drop implementation that would support webkit-mobile browsers as well as desktop browsers and that would not pollute the JavaScript runtime with unneeded code.
There are basically two ways implement a Drag&Drop System with the given DOM-Events in JavaScript

### GLOBAL
The drag-handler starts when the mousedown-event (touchstart on webkit-mobile) is fired on an element with the css class "draggable". This element is then saved as the global drag-target together with its current position. All mousemove-/touchmove events that are then fired on the document initiate a movement-delta calculation and a custom drag-event that is fired on the current drag-target. These delta values can be used to alter the element's current top and left css-values according to the movement.
On mouseup/touchend a "dragend" event is fired and the current drag-target is set to null so that another element can be dragged the next time a drag is initiated.
While this method is perfectly functional it has some downsides when it comes to touch-device users. When I implemented all the Drag&Drop of Salon in this way and showed iPad users the outcome they were confused that they could only drag one item at a time. The fact that movement is detected by move events on the document only allows tracking one finger at the same time. The users were not only confused but also thought that the app was not working properly. To give iPad users a better experience I though about how to implement a multi-touch system and came up with the "local" Drag&Drop system.

### LOCAL
To allow multi-touch dragging of elements I had to rethink my global drag-target system. One of the main problems with not having one single drag-target is to find out on which element each mousemove/touchmove-event has occurred because the event-target may not be the actual drag target due to other overlapping elements with a higher z-index. Tracking a list of drag-targets also is no solution to the problem because drag-targets could also overlap and a lookup for an element on a certain position may return more than one element.
The general problem is that without knowing the first and the last position of an element it is not possible to calculate a movement delta. The easiest solution I found was to store this information in memory via the jQuery data()Â [link] method that allows you to associate data to DOM-elements. In that way it was very easy to calculate all needed values.
This version had a downside too, because when moving the mouse very quickly the target every time lost focus and stopped. This made it impossible to use with a mouse and so I added both systems and only activated the local variant on touch devices.

The reason why I decided not to move the elements directly in the drag-handler is because I wanted to keep the system as decoupled as possible. In that way I left it open to event receivers how to move elements on the screen (e.g. top/left css attributes or negative margins). Also it is possible in this way to only move the element on one axis if wanted.

### DROP
All elements that have the css class "droppable" are capable of receiving drop-events ("drop", "drag_over"). When a drag event is fired, the system automatically looks for elements that can receive a "drag_over" event by matching the current position with the positions of all droppable elements. This event is useful to give users a feedback that they can drop elements on this element e.g. by increasing its size or by changing its color. If the user drops an element the underlying droppable element will receive the drop event that includes the current drag-target.